#### [[Вопросы к Экзамену]]
---
Алгоритм оптимального префиксного кодирования алфавита.
*Опр.* $$\begin{align}
	&\text{Пусть. } A =\{a_1,a_2,\ldots,a_n\}\text{ — алфавит из }n\text{ различных символов}, \\
	&W = \{w_1,w_2,\ldots,w_n\}\text{ — соответствующий ему набор положительных целых весов}. \\
	&\text{Тогда набор бинарных кодов } C=\{c_1,c_2,\ldots,c_n\}, \text{ где } c_i\text{ является кодом символа }a_i,\\
	&\text{такой, что:} \\
	&\quad\cdot\ c_i\text{ не является префиксом для }c_j\text{, при } i\not=j,\\
	&\quad\cdot\ \text{сумма }\sum_{i\in[1,n]}{w_i\cdot|c_i|}\text{ минимальна} (|c_i|\text{ — длина кода } c_i), \\
\end{align}$$ называется **кодом Хаффмана**.
#### Алгоритм построения бинарного кода Хаффмана
Построение кода Хаффмана сводится к построению соответствующего бинарного дерева по следующему алгоритму:

1. Составим список кодируемых символов, при этом будем рассматривать один символ как дерево, состоящее из одного элемента c весом, равным частоте появления символа в строке.
2. Из списка выберем два узла с наименьшим весом.
3. Сформируем новый узел с весом, равным сумме весов выбранных узлов, и присоединим к нему два выбранных узла в качестве детей.
4. Добавим к списку только что сформированный узел вместо двух объединенных узлов.
5. Если в списке больше одного узла, то повторим пункты со второго по пятый.
#### Пример
Закодируем слово ***abracadabra***. Тогда алфавит будет $A={a,b,r,c,d}$, а набор весов (частота появления символов алфавита в кодируемом слове) $W={5,2,2,1,1}$:
В дереве Хаффмана будет $5$ узлов:

|Узел|a|b|r|с|d|
|---|---|---|---|---|---|
|Вес|5|2|2|1|1|

По алгоритму возьмем два символа с наименьшей частотой — это $c$ и $d$. Сформируем из них новый узел $cd$ весом $2$ и добавим его к списку узлов:

| Узел | a   | b   | r   | cd  |
| ---- | --- | --- | --- | --- |
| Вес  | 5   | 2   | 2   | 2   |

Затем опять объединим в один узел два минимальных по весу узла — $r$ и $cd$:

| Узел | a   | rcd | b   |
| ---- | --- | --- | --- |
| Вес  | 5   | 4   | 2   |

Еще раз повторим эту же операцию, но для узлов $rcd$ и $b$:

| Узел | brcd | a   |
| ---- | ---- | --- |
| Вес  | 6    | 5   |

На последнем шаге объединим два узла — $brcd$ и $a$:

| Узел | abrcd |
| ---- | ----- |
| Вес  | 11    |

Остался один узел, значит, мы пришли к корню дерева Хаффмана. Теперь для каждого символа выберем кодовое слово (бинарная последовательность, обозначающая путь по дереву к этому символу от корня):

|Символ|a|b|r|с|d|
|---|---|---|---|---|---|
|Код|0|11|101|1000|1001|

Таким образом, закодированное слово ***abracadabra*** будет выглядеть как $01110101000010010111010$. Длина закодированного слова — 23 бита. Стоит заметить, что если бы мы использовали алгоритм кодирования с одинаковой длиной всех кодовых слов, то закодированное слово заняло бы 33 бита, что существенно больше.
Дерево Хаффмана для слова ***abracadabra*** ![[Haffman's tree.png]] 